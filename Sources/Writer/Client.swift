// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

/// An object used to make API calls.
///
/// ``Client`` is the main object that you interact with to communicate with the API, and is responsible for making the underlying HTTP requests for each API operation and handling the resulting responses. It implements the ``WriterAPI`` protocol to support the available API operations.
///
/// ### API calls
///
/// Each API endpoint (or *operation*) is exposed as a method. For instance, the 'detectContent' operation is exposed as:
///
/// ```swift
/// func detectContent(request: Operations.DetectContentRequest) async throws -> Operations.DetectContentResponse
/// ```
///
/// ### Request and response objects
///
/// If an API operation has input parameters, the corresponding API methods take a `request` object, describing these parameters. The request object can either be a primitive value like a `String` or `[String]`, or a Swift `struct` describing the parameters.
///
/// Each API method also returns a response object, which may also be a primitive or a Swift `struct`. In addition to any data returned by a given API operation, each response object contains information about the network request, including:
/// - The `contentType` returned by the server.
/// - The `statusCode` representing the HTTP status code returned by making the request
/// - A `rawResponse` value which is the raw [HTTPURLResponse](https://developer.apple.com/documentation/foundation/httpurlresponse) returned from making the underlying network request.
///
/// These values can be used to debug and/or react to responses returned from executing a given API operation.
///
/// ### Authentication
///
/// Calls to the API must be authenticated, and ``Client`` must be initialized with a configured ``Shared/Security`` object to authenticate requests.
///
/// ## Topics
///
/// ### Initializers
///
/// - ``init(globalParameters:security:)``
///
/// ### API calls
///
/// These methods allow you to make requests to the API.
///
///
/// ### Scoped API calls
///
/// These properties logically group other parts of the API.
///
/// - ``aiContentDetector``
/// - ``billing``
/// - ``coWrite``
/// - ``completions``
/// - ``content``
/// - ``downloadTheCustomizedModel``
/// - ``files``
/// - ``modelCustomization``
/// - ``models``
/// - ``snippet``
/// - ``styleguide``
/// - ``terminology``
/// - ``user``
/// - ``document``
///
public final class Client {
    internal typealias ConfigureURLRequest = (_ configuration: URLRequestConfiguration) throws -> Void
    internal typealias ResponseHandler<ResponseObject> = (_ response: WriterResponse) throws -> ResponseObject

    private lazy var session = URLSession(configuration: .default)
    private var globalParameters: GlobalParameters?
    private var security: Shared.Security

    private var selectedServer: GlobalServers?

    /// Creates an API client object with the specified parameters.
    public init(globalParameters: GlobalParameters? = nil, security: Shared.Security) {
        self.globalParameters = globalParameters
        self.security = security
    }

    // MARK: - Internal

    internal func makeRequest<ResponseObject>(
        with server: Server? = nil,
        configureRequest: @escaping ConfigureURLRequest,
        handleResponse responseHandler: @escaping ResponseHandler<ResponseObject>
    ) async throws -> ResponseObject {
        return try await withCheckedThrowingContinuation { continuation in
            makeRequest(with: server, configureRequest: configureRequest) { result in
                do {
                    let response = try result.get()
                    let responseObject = try responseHandler(response)
                    continuation.resume(returning: responseObject)
                } catch let error as ServerConversionError {
                    switch error {
                    case .internal:
                        continuation.resume(throwing: WriterError.internalError(error: nil))
                    case .missingDefaultServer(let serverType):
                        continuation.resume(throwing: WriterError.failedToConstructRequestURL(.missingDefaultServer(serverType: serverType)))
                    case .invalidServerIndex(let serverType, let index):
                        continuation.resume(throwing: WriterError.failedToConstructRequestURL(.invalidServerIndex(serverType: serverType, index: index)))
                    case .missingServerParameterSubstitutionKey(let key, let serverString):
                        continuation.resume(throwing: WriterError.failedToSerializeRequestParameters(.missingServerParameterSubstitutionKey(key, serverString: serverString)))
                    }
                } catch let error as URLRequestBuilderError {
                    switch error {
                    case .internalError:
                        continuation.resume(throwing: WriterError.internalError(error: nil))
                    case .invalidURL(let urlString):
                        continuation.resume(throwing: WriterError.failedToConstructRequestURL(.invalidRequestURL(string: urlString)))
                    case .missingPathParameterSubstitutionKey(let key, let path):
                        continuation.resume(throwing: WriterError.failedToSerializeRequestParameters(.missingPathParameterSubstitutionKey(key, path: path)))
                    }
                } catch let error as SerializationError {
                    switch error {
                    case .failedToSerializeData:
                        continuation.resume(throwing: WriterError.failedToSerializeRequestParameters(.failedToSerializeData))
                    case .missingRequiredRequestBody:
                        continuation.resume(throwing: WriterError.failedToConstructRequest(.missingRequiredRequestBody))
                    case .invalidSerializationParameter(let type, let format):
                        continuation.resume(throwing: WriterError.failedToSerializeRequestParameters(.invalidSerializationParameter(type: type, format: format)))
                    }
                } catch let error as ResponseHandlerError {
                    switch error {
                    case .failedToDecodeJSON(let error):
                        continuation.resume(throwing: WriterError.failedToHandleResponse(.failedToDeserializeJSON(error)))
                    }
                } catch let error as WriterError {
                    continuation.resume(throwing: error)
                } catch {
                    continuation.resume(throwing: WriterError.internalError(error: error))
                }
            }
        }
    }

    internal func makeRequest(
        with server: Server? = nil,
        configureRequest: ConfigureURLRequest,
        completion: @escaping (Result<WriterResponse, Swift.Error>) -> Void
    ) {
        do {
            let builder = URLRequestBuilder(
                baseURL: try baseURL(serverOverride: server),
                parameterDefaults: globalParameters,
                defaultSecurityParameterProviding: security
            )
            try configureRequest(builder)
            return makeDataRequest(with: try builder.build(), completion: completion)
        } catch {
            completion(.failure(error))
        }
    }

    // MARK: - Private

    private func baseURL(serverOverride: Server? = nil) throws -> URL {
        let server: Server
        if let serverOverride {
            server = serverOverride
        } else if let selectedServer {
            server = try selectedServer.server()
        } else {
            server = try GlobalServers.default()
        }

        guard let url = URL(string: server.urlString) else {
            throw WriterError.failedToConstructRequestURL(.invalidServerURL(string: server.urlString))
        }
        return url
    }

    private func makeDataRequest(with urlRequest: URLRequest, completion: @escaping (Result<WriterResponse, Swift.Error>) -> Void) {
        let task = session.dataTask(with: urlRequest) { data, response, error in
            if let error {
                completion(.failure(WriterError.failedToMakeNetworkRequest(error: error)))
            } else if let httpResponse = response as? HTTPURLResponse {
                completion(.success(WriterResponse(httpResponse: httpResponse, data: data)))
            } else {
                completion(.failure(WriterError.internalError(error: nil)))
            }
        }
        task.resume()
    }
}

enum ResponseHandlerError: Swift.Error {
    case failedToDecodeJSON(_ error: Swift.Error)
}
