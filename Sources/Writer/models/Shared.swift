// Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.

import Foundation

/// Top-level type used for grouping shared models
///
/// > Note: You do not need to interact with this type directly.
public struct Shared {
    private init() {}

    /// Describes the available authentication methods when connecting to the API.
    public enum Security {
        case apiKey(String)
    }

    /// Bad Request
    public struct FailResponse {
        public let extras: AnyValue
        public let tpe: String
        public let errors: [Shared.FailMessage]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(extras: AnyValue, tpe: String, errors: [Shared.FailMessage]? = nil) {
            self.extras = extras
            self.tpe = tpe
            self.errors = errors
        }
    }

    /// A model object
    public struct FailMessage {
        public let description: String
        public let extras: AnyValue
        public let key: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(description: String, extras: AnyValue, key: String) {
            self.description = description
            self.extras = extras
            self.key = key
        }
    }

    public enum ContentDetectorResponseLabel: String, Codable, APIValue {
        case fake = "fake"
        case real = "real"
    }

    /// A model object
    public struct ContentDetectorResponse {
        public let label: Shared.ContentDetectorResponseLabel
        @DecimalSerialized
        public private(set) var score: Double

        /// Creates an object with the specified parameters
        ///
        ///
        public init(label: Shared.ContentDetectorResponseLabel, score: Double) {
            self.label = label
            self._score = DecimalSerialized<Double>(wrappedValue: score)
        }
    }

    /// A request model
    public struct ContentDetectorRequest {
        public let input: String

        /// Creates a request model with the specified parameters
        ///
        ///
        public init(input: String) {
            self.input = input
        }
    }

    public enum SubscriptionPublicResponseApiProductName: String, Codable, APIValue {
        case free = "free"
        case pro = "pro"
        case team = "team"
        case enterprise = "enterprise"
        case legacy = "legacy"
    }

    public enum SubscriptionPublicResponseApiStatus: String, Codable, APIValue {
        case trialing = "trialing"
        case active = "active"
        case pastDue = "past_due"
        case incomplete = "incomplete"
        case incompleteExpired = "incomplete_expired"
        case unpaid = "unpaid"
        case canceled = "canceled"
    }

    /// A model object
    public struct SubscriptionPublicResponseApi {
        @DateTime
        public private(set) var createdAt: Date
        public let meta: Shared.MetaData
        public let productName: Shared.SubscriptionPublicResponseApiProductName
        public let seats: Int
        public let status: Shared.SubscriptionPublicResponseApiStatus
        public let subscriptionId: String
        public let usage: Shared.Usage

        /// Creates an object with the specified parameters
        ///
        ///
        public init(createdAt: Date, meta: Shared.MetaData, productName: Shared.SubscriptionPublicResponseApiProductName, seats: Int, status: Shared.SubscriptionPublicResponseApiStatus, subscriptionId: String, usage: Shared.Usage) {
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.meta = meta
            self.productName = productName
            self.seats = seats
            self.status = status
            self.subscriptionId = subscriptionId
            self.usage = usage
        }
    }

    /// A model object
    public struct Usage {
        public let coWriteWords: Shared.UsageItem
        public let team: Shared.UsageItem
        public let user: Shared.UsageItem
        public let words: Shared.UsageItem

        /// Creates an object with the specified parameters
        ///
        ///
        public init(coWriteWords: Shared.UsageItem, team: Shared.UsageItem, user: Shared.UsageItem, words: Shared.UsageItem) {
            self.coWriteWords = coWriteWords
            self.team = team
            self.user = user
            self.words = words
        }
    }

    /// A model object
    public struct UsageItem {
        public let limit: Int
        public let value: Int

        /// Creates an object with the specified parameters
        ///
        ///
        public init(limit: Int, value: Int) {
            self.limit = limit
            self.value = value
        }
    }

    public enum MetaDataTier: String, Codable, APIValue {
        case enterprise1 = "enterprise-1"
        case enterprise2 = "enterprise-2"
        case enterprise3 = "enterprise-3"
        case enterprise4 = "enterprise-4"
    }

    /// A model object
    public struct MetaData {
        public let portal: [String: String]
        public let reporting: [String: String]
        public let snippetsCount: Int
        public let ssoAccess: Bool
        public let styleguide: [String: String]
        public let teamCount: Int
        public let termsCount: Int
        public let tier: Shared.MetaDataTier?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(portal: [String: String], reporting: [String: String], snippetsCount: Int, ssoAccess: Bool, styleguide: [String: String], teamCount: Int, termsCount: Int, tier: Shared.MetaDataTier? = nil) {
            self.portal = portal
            self.reporting = reporting
            self.snippetsCount = snippetsCount
            self.ssoAccess = ssoAccess
            self.styleguide = styleguide
            self.teamCount = teamCount
            self.termsCount = termsCount
            self.tier = tier
        }
    }

    /// A model object
    public struct Draft {
        public let body: String
        public let createdUserId: Int
        @DateTime
        public private(set) var creationTime: Date
        public let deleted: Bool
        public let documentId: String
        public let inputs: AnyValue
        public let organizationId: Int
        public let teamId: Int
        public let templateId: String
        public let id: Int?
        public let title: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(body: String, createdUserId: Int, creationTime: Date, deleted: Bool, documentId: String, inputs: AnyValue, organizationId: Int, teamId: Int, templateId: String, id: Int? = nil, title: String? = nil) {
            self.body = body
            self.createdUserId = createdUserId
            self._creationTime = DateTime<Date>(wrappedValue: creationTime)
            self.deleted = deleted
            self.documentId = documentId
            self.inputs = inputs
            self.organizationId = organizationId
            self.teamId = teamId
            self.templateId = templateId
            self.id = id
            self.title = title
        }
    }

    /// A request model
    public struct GenerateTemplateRequest {
        public let templateId: String
        public let inputs: [Shared.MagicRequestInput]?

        /// Creates a request model with the specified parameters
        ///
        ///
        public init(templateId: String, inputs: [Shared.MagicRequestInput]? = nil) {
            self.templateId = templateId
            self.inputs = inputs
        }
    }

    /// A model object
    public struct MagicRequestInput {
        public let name: String
        public let value: [String]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(name: String, value: [String]? = nil) {
            self.name = name
            self.value = value
        }
    }

    /// A model object
    public struct TemplateDetailsResponse {
        public let categoryId: Int
        @DateTime
        public private(set) var creationTime: Date
        public let id: String
        @DateTime
        public private(set) var modificationTime: Date
        public let name: String
        public let description: String?
        public let guideUrl: String?
        public let inputs: [Shared.Input]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(categoryId: Int, creationTime: Date, id: String, modificationTime: Date, name: String, description: String? = nil, guideUrl: String? = nil, inputs: [Shared.Input]? = nil) {
            self.categoryId = categoryId
            self._creationTime = DateTime<Date>(wrappedValue: creationTime)
            self.id = id
            self._modificationTime = DateTime<Date>(wrappedValue: modificationTime)
            self.name = name
            self.description = description
            self.guideUrl = guideUrl
            self.inputs = inputs
        }
    }

    public enum InputType: String, Codable, APIValue {
        case textbox = "textbox"
        case textarea = "textarea"
        case dropdown = "dropdown"
    }

    /// A model object
    public struct Input {
        public let `dynamic`: Bool
        public let name: String
        public let `required`: Bool
        public let type: Shared.InputType
        public let help: String?
        public let maxFields: Int?
        public let minFields: Int?
        public let options: [String]?
        public let subtitle: String?
        public let unitCopy: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(dynamic: Bool, name: String, required: Bool, type: Shared.InputType, help: String? = nil, maxFields: Int? = nil, minFields: Int? = nil, options: [String]? = nil, subtitle: String? = nil, unitCopy: String? = nil) {
            self.`dynamic` = `dynamic`
            self.name = name
            self.`required` = `required`
            self.type = type
            self.help = help
            self.maxFields = maxFields
            self.minFields = minFields
            self.options = options
            self.subtitle = subtitle
            self.unitCopy = unitCopy
        }
    }

    /// A model object
    public struct CompletionResponse {
        public let choices: [Shared.CompletionGenerationChoice]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(choices: [Shared.CompletionGenerationChoice]? = nil) {
            self.choices = choices
        }
    }

    /// A model object
    public struct CompletionGenerationChoice {
        public let text: String
        public let logprobs: Shared.CompletionGenerationChoiceLogprobs?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(text: String, logprobs: Shared.CompletionGenerationChoiceLogprobs? = nil) {
            self.text = text
            self.logprobs = logprobs
        }
    }

    /// A model object
    public struct CompletionGenerationChoiceLogprobs {
        public let textOffset: [Int]?
        public let tokenLogprobs: [Double]?
        public let tokens: [String]?
        public let topLogprobs: [[String: String]]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(textOffset: [Int]? = nil, tokenLogprobs: [Double]? = nil, tokens: [String]? = nil, topLogprobs: [[String: String]]? = nil) {
            self.textOffset = textOffset
            self.tokenLogprobs = tokenLogprobs
            self.tokens = tokens
            self.topLogprobs = topLogprobs
        }
    }

    /// A request model
    public struct CompletionRequest {
        public let prompt: String
        public let bestOf: Int?
        @DecimalSerialized
        public private(set) var frequencyPenalty: Double?
        public let logprobs: Int?
        public let maxTokens: Int?
        public let minTokens: Int?
        public let n: Int?
        @DecimalSerialized
        public private(set) var presencePenalty: Double?
        public let stop: [String]?
        @DecimalSerialized
        public private(set) var temperature: Double?
        @DecimalSerialized
        public private(set) var topP: Double?

        /// Creates a request model with the specified parameters
        ///
        ///
        public init(prompt: String, bestOf: Int? = nil, frequencyPenalty: Double? = nil, logprobs: Int? = nil, maxTokens: Int? = nil, minTokens: Int? = nil, n: Int? = nil, presencePenalty: Double? = nil, stop: [String]? = nil, temperature: Double? = nil, topP: Double? = nil) {
            self.prompt = prompt
            self.bestOf = bestOf
            self._frequencyPenalty = DecimalSerialized<Double?>(wrappedValue: frequencyPenalty)
            self.logprobs = logprobs
            self.maxTokens = maxTokens
            self.minTokens = minTokens
            self.n = n
            self._presencePenalty = DecimalSerialized<Double?>(wrappedValue: presencePenalty)
            self.stop = stop
            self._temperature = DecimalSerialized<Double?>(wrappedValue: temperature)
            self._topP = DecimalSerialized<Double?>(wrappedValue: topP)
        }
    }

    /// A model object
    public struct ProcessedContent {
        public let issues: [Shared.ContentIssue]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(issues: [Shared.ContentIssue]? = nil) {
            self.issues = issues
        }
    }

    public enum ContentIssueService: String, Codable, APIValue {
        case commonMistakes = "common-mistakes"
        case bannedWords = "banned-words"
        case dictionary = "dictionary"
        case gec = "gec"
        case infinitive = "infinitive"
        case spelling = "spelling"
        case writingStyle = "writing-style"
        case customRules = "custom-rules"
        case sentenceCase = "sentence-case"
        case acronym = "acronym"
        case oxfordComma = "oxford-comma"
        case mlPunctuation = "ml-punctuation"
        case emojis = "emojis"
        case genderPronouns = "gender-pronouns"
        case sensitivity = "sensitivity"
        case plagiarism = "plagiarism"
        case readability = "readability"
        case sentenceComplexity = "sentence-complexity"
        case vocabulary = "vocabulary"
        case paragraphLength = "paragraph-length"
        case plainLanguage = "plain-language"
        case healthyCommn = "healthy-commn"
        case confidence = "confidence"
        case dataLossPrevention = "data-loss-prevention"
        case hateSpeech = "hate-speech"
        case contentSafeguards = "content-safeguards"
        case feedback = "feedback"
        case claim = "claim"
        case quote = "quote"
        case genderNouns = "gender-nouns"
        case genderTone = "gender-tone"
        case grammar = "grammar"
        case punctuationDark = "punctuation-dark"
        case formatting = "formatting"
        case twitter = "twitter"
        case gecDark = "gec-dark"
        case gecGpt3 = "gec-gpt3"
    }

    /// A model object
    public struct ContentIssue {
        public let from: Int
        public let service: Shared.ContentIssueService
        public let until: Int
        public let description: String?
        public let meta: AnyValue?
        public let suggestions: [String]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(from: Int, service: Shared.ContentIssueService, until: Int, description: String? = nil, meta: AnyValue? = nil, suggestions: [String]? = nil) {
            self.from = from
            self.service = service
            self.until = until
            self.description = description
            self.meta = meta
            self.suggestions = suggestions
        }
    }

    /// A request model
    public struct ContentRequest {
        public let content: String
        public let settings: Shared.ContentSettings

        /// Creates a request model with the specified parameters
        ///
        ///
        public init(content: String, settings: Shared.ContentSettings) {
            self.content = content
            self.settings = settings
        }
    }

    /// A model object
    public struct ContentSettings {
        public let ageAndFamilyStatus: Bool
        public let confidence: Bool
        public let contentSafeguards: Bool
        public let disability: Bool
        public let genderIdentitySensitivity: Bool
        public let genderInclusiveNouns: Bool
        public let genderInclusivePronouns: Bool
        public let grammar: Bool
        public let healthyCommunication: Bool
        public let passiveVoice: Bool
        public let raceEthnicityNationalitySensitivity: Bool
        public let sexualOrientationSensitivity: Bool
        public let spelling: Bool
        public let substanceUseSensitivity: Bool
        public let unclearReference: Bool
        public let wordiness: Bool

        /// Creates an object with the specified parameters
        ///
        ///
        public init(ageAndFamilyStatus: Bool, confidence: Bool, contentSafeguards: Bool, disability: Bool, genderIdentitySensitivity: Bool, genderInclusiveNouns: Bool, genderInclusivePronouns: Bool, grammar: Bool, healthyCommunication: Bool, passiveVoice: Bool, raceEthnicityNationalitySensitivity: Bool, sexualOrientationSensitivity: Bool, spelling: Bool, substanceUseSensitivity: Bool, unclearReference: Bool, wordiness: Bool) {
            self.ageAndFamilyStatus = ageAndFamilyStatus
            self.confidence = confidence
            self.contentSafeguards = contentSafeguards
            self.disability = disability
            self.genderIdentitySensitivity = genderIdentitySensitivity
            self.genderInclusiveNouns = genderInclusiveNouns
            self.genderInclusivePronouns = genderInclusivePronouns
            self.grammar = grammar
            self.healthyCommunication = healthyCommunication
            self.passiveVoice = passiveVoice
            self.raceEthnicityNationalitySensitivity = raceEthnicityNationalitySensitivity
            self.sexualOrientationSensitivity = sexualOrientationSensitivity
            self.spelling = spelling
            self.substanceUseSensitivity = substanceUseSensitivity
            self.unclearReference = unclearReference
            self.wordiness = wordiness
        }
    }

    /// A model object
    public struct CorrectionResponse {
        public let correct: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(correct: String) {
            self.correct = correct
        }
    }

    /// A model object
    public struct ModelFile {
        @DateTime
        public private(set) var createdAt: Date
        public let format: String
        public let id: String
        public let name: String
        public let numberOfSamples: Int
        public let size: Int

        /// Creates an object with the specified parameters
        ///
        ///
        public init(createdAt: Date, format: String, id: String, name: String, numberOfSamples: Int, size: Int) {
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.format = format
            self.id = id
            self.name = name
            self.numberOfSamples = numberOfSamples
            self.size = size
        }
    }

    /// A model object
    public struct ModelFilesResponse {
        public let files: [Shared.ModelFile]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(files: [Shared.ModelFile]? = nil) {
            self.files = files
        }
    }

    /// A model object
    public struct UploadModelFileRequestFile: APIValue {
        public let content: Data
        public let file: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(content: Data, file: String) {
            self.content = content
            self.file = file
        }
    }

    /// A request model
    public struct UploadModelFileRequest: APIValue {
        public let file: Shared.UploadModelFileRequestFile

        /// Creates a request model with the specified parameters
        ///
        ///
        public init(file: Shared.UploadModelFileRequestFile) {
            self.file = file
        }
    }

    /// A model object
    public struct ModelCustomization {
        public let baseModelId: String
        @DateTime
        public private(set) var createdAt: Date
        public let id: String
        public let name: String
        public let status: String
        public let trainingDatasetFileId: String
        @DateTime
        public private(set) var updatedAt: Date
        public let additionalHyperParameters: Shared.HyperParameters?
        public let batchSize: Int?
        public let description: String?
        public let epochs: Int?
        @DecimalSerialized
        public private(set) var learningRate: Double?
        public let promptTemplate: String?
        public let validationDatasetFileId: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(baseModelId: String, createdAt: Date, id: String, name: String, status: String, trainingDatasetFileId: String, updatedAt: Date, additionalHyperParameters: Shared.HyperParameters? = nil, batchSize: Int? = nil, description: String? = nil, epochs: Int? = nil, learningRate: Double? = nil, promptTemplate: String? = nil, validationDatasetFileId: String? = nil) {
            self.baseModelId = baseModelId
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.id = id
            self.name = name
            self.status = status
            self.trainingDatasetFileId = trainingDatasetFileId
            self._updatedAt = DateTime<Date>(wrappedValue: updatedAt)
            self.additionalHyperParameters = additionalHyperParameters
            self.batchSize = batchSize
            self.description = description
            self.epochs = epochs
            self._learningRate = DecimalSerialized<Double?>(wrappedValue: learningRate)
            self.promptTemplate = promptTemplate
            self.validationDatasetFileId = validationDatasetFileId
        }
    }

    /// A model object
    public struct HyperParameters {
        public let numVirtualTokens: Int

        /// Creates an object with the specified parameters
        ///
        ///
        public init(numVirtualTokens: Int) {
            self.numVirtualTokens = numVirtualTokens
        }
    }

    /// A request model
    public struct CreateCustomizationRequest {
        public let name: String
        public let trainingDatasetFileId: String
        public let additionalHyperParameters: Shared.HyperParameters?
        public let batchSize: Int?
        public let description: String?
        public let epochs: Int?
        @DecimalSerialized
        public private(set) var learningRate: Double?
        public let promptTemplate: String?
        public let validationDatasetFileId: String?

        /// Creates a request model with the specified parameters
        ///
        ///
        public init(name: String, trainingDatasetFileId: String, additionalHyperParameters: Shared.HyperParameters? = nil, batchSize: Int? = nil, description: String? = nil, epochs: Int? = nil, learningRate: Double? = nil, promptTemplate: String? = nil, validationDatasetFileId: String? = nil) {
            self.name = name
            self.trainingDatasetFileId = trainingDatasetFileId
            self.additionalHyperParameters = additionalHyperParameters
            self.batchSize = batchSize
            self.description = description
            self.epochs = epochs
            self._learningRate = DecimalSerialized<Double?>(wrappedValue: learningRate)
            self.promptTemplate = promptTemplate
            self.validationDatasetFileId = validationDatasetFileId
        }
    }

    /// A model object
    public struct CustomizationsResponse {
        public let customizations: [Shared.ModelCustomization]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(customizations: [Shared.ModelCustomization]? = nil) {
            self.customizations = customizations
        }
    }

    /// A model object
    public struct GenerationModelsResponse {
        public let data: [Shared.GenerationModelInfoResponse]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(data: [Shared.GenerationModelInfoResponse]? = nil) {
            self.data = data
        }
    }

    public enum GenerationModelInfoResponseType: String, Codable, APIValue {
        case gpt = "GPT"
        case instruct = "Instruct"
    }

    /// A model object
    public struct GenerationModelInfoResponse {
        public let id: String
        public let name: String
        public let type: Shared.GenerationModelInfoResponseType

        /// Creates an object with the specified parameters
        ///
        ///
        public init(id: String, name: String, type: Shared.GenerationModelInfoResponseType) {
            self.id = id
            self.name = name
            self.type = type
        }
    }

    /// A model object
    public struct DeleteResponse {
        public let deleted: Int

        /// Creates an object with the specified parameters
        ///
        ///
        public init(deleted: Int) {
            self.deleted = deleted
        }
    }

    /// A model object
    public struct PaginatedResultSnippetWithUser {
        public let pagination: Shared.Pagination
        public let totalCount: Int
        public let result: [Shared.SnippetWithUser]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(pagination: Shared.Pagination, totalCount: Int, result: [Shared.SnippetWithUser]? = nil) {
            self.pagination = pagination
            self.totalCount = totalCount
            self.result = result
        }
    }

    /// A model object
    public struct SnippetWithUser {
        public let createdUser: Shared.TerminologyUser
        @DateTime
        public private(set) var creationTime: Date
        public let id: String
        @DateTime
        public private(set) var modificationTime: Date
        public let modifiedUser: Shared.TerminologyUser
        public let snippet: String
        public let description: String?
        public let shortcut: String?
        public let tags: [Shared.SnippetTagV2]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(createdUser: Shared.TerminologyUser, creationTime: Date, id: String, modificationTime: Date, modifiedUser: Shared.TerminologyUser, snippet: String, description: String? = nil, shortcut: String? = nil, tags: [Shared.SnippetTagV2]? = nil) {
            self.createdUser = createdUser
            self._creationTime = DateTime<Date>(wrappedValue: creationTime)
            self.id = id
            self._modificationTime = DateTime<Date>(wrappedValue: modificationTime)
            self.modifiedUser = modifiedUser
            self.snippet = snippet
            self.description = description
            self.shortcut = shortcut
            self.tags = tags
        }
    }

    /// A model object
    public struct SnippetTagV2 {
        public let tag: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(tag: String) {
            self.tag = tag
        }
    }

    /// A model object
    public struct TerminologyUser {
        public let id: Int
        public let email: String?
        public let fullName: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(id: Int, email: String? = nil, fullName: String? = nil) {
            self.id = id
            self.email = email
            self.fullName = fullName
        }
    }

    /// A model object
    public struct Pagination {
        public let limit: Int?
        public let offset: Int?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(limit: Int? = nil, offset: Int? = nil) {
            self.limit = limit
            self.offset = offset
        }
    }

    /// A model object
    public struct SnippetUpdate {
        public let id: String
        public let snippet: String
        public let description: String?
        public let shortcut: String?
        public let tags: [Shared.SnippetTagV2]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(id: String, snippet: String, description: String? = nil, shortcut: String? = nil, tags: [Shared.SnippetTagV2]? = nil) {
            self.id = id
            self.snippet = snippet
            self.description = description
            self.shortcut = shortcut
            self.tags = tags
        }
    }

    public enum PageWithSectionResponseStatus: String, Codable, APIValue {
        case live = "live"
        case offline = "offline"
    }

    /// A model object
    public struct PageWithSectionResponse {
        @DateTime
        public private(set) var createdAt: Date
        public let id: Int
        public let order: Int
        public let status: Shared.PageWithSectionResponseStatus
        public let title: String
        @DateTime
        public private(set) var updatedAt: Date
        public let url: String
        public let content: String?
        public let section: Shared.SectionInfo?
        public let updatedBy: Shared.SimpleUser?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(createdAt: Date, id: Int, order: Int, status: Shared.PageWithSectionResponseStatus, title: String, updatedAt: Date, url: String, content: String? = nil, section: Shared.SectionInfo? = nil, updatedBy: Shared.SimpleUser? = nil) {
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.id = id
            self.order = order
            self.status = status
            self.title = title
            self._updatedAt = DateTime<Date>(wrappedValue: updatedAt)
            self.url = url
            self.content = content
            self.section = section
            self.updatedBy = updatedBy
        }
    }

    /// A model object
    public struct SimpleUser {
        public let firstName: String
        public let id: Int
        public let email: String?
        public let lastName: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(firstName: String, id: Int, email: String? = nil, lastName: String? = nil) {
            self.firstName = firstName
            self.id = id
            self.email = email
            self.lastName = lastName
        }
    }

    /// A model object
    public struct SectionInfo {
        public let id: Int
        public let title: String
        public let url: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(id: Int, title: String, url: String) {
            self.id = id
            self.title = title
            self.url = url
        }
    }

    /// A model object
    public struct PaginatedResultPagePublicApiResponse {
        public let pagination: Shared.Pagination
        public let totalCount: Int
        public let result: [Shared.PagePublicApiResponse]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(pagination: Shared.Pagination, totalCount: Int, result: [Shared.PagePublicApiResponse]? = nil) {
            self.pagination = pagination
            self.totalCount = totalCount
            self.result = result
        }
    }

    public enum PagePublicApiResponseStatus: String, Codable, APIValue {
        case live = "live"
        case offline = "offline"
    }

    /// A model object
    public struct PagePublicApiResponse {
        @DateTime
        public private(set) var createdAt: Date
        public let id: Int
        public let order: Int
        public let status: Shared.PagePublicApiResponseStatus
        public let title: String
        @DateTime
        public private(set) var updatedAt: Date
        public let url: String
        public let section: Shared.SectionInfo?
        public let updatedBy: Shared.SimpleUser?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(createdAt: Date, id: Int, order: Int, status: Shared.PagePublicApiResponseStatus, title: String, updatedAt: Date, url: String, section: Shared.SectionInfo? = nil, updatedBy: Shared.SimpleUser? = nil) {
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.id = id
            self.order = order
            self.status = status
            self.title = title
            self._updatedAt = DateTime<Date>(wrappedValue: updatedAt)
            self.url = url
            self.section = section
            self.updatedBy = updatedBy
        }
    }

    /// A model object
    public struct CreateTermsResponse {
        public let fails: [Shared.FailMessage]?
        public let models: [Shared.FullTermWithUser]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(fails: [Shared.FailMessage]? = nil, models: [Shared.FullTermWithUser]? = nil) {
            self.fails = fails
            self.models = models
        }
    }

    public enum FullTermWithUserPos: String, Codable, APIValue {
        case noun = "noun"
        case verb = "verb"
        case adverb = "adverb"
        case adjective = "adjective"
    }

    public enum FullTermWithUserType: String, Codable, APIValue {
        case approved = "approved"
        case banned = "banned"
        case pending = "pending"
    }

    /// A model object
    public struct FullTermWithUser {
        public let caseSensitive: Bool
        public let createdUser: Shared.TerminologyUser
        @DateTime
        public private(set) var creationTime: Date
        public let highlight: Bool
        public let id: Int
        @DateTime
        public private(set) var modificationTime: Date
        public let modifiedUser: Shared.TerminologyUser
        public let term: String
        public let termBankId: Int
        public let type: Shared.FullTermWithUserType
        public let approvedTermExtension: Shared.ApprovedTermExtension?
        public let backlinkedTerms: [Shared.FullLinkedTerm]?
        public let description: String?
        public let examples: [Shared.TermExample]?
        public let linkedTerms: [Shared.FullLinkedTerm]?
        public let mistakes: [Shared.TermMistake]?
        public let pos: Shared.FullTermWithUserPos?
        public let tags: [Shared.TermTagResponse]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(caseSensitive: Bool, createdUser: Shared.TerminologyUser, creationTime: Date, highlight: Bool, id: Int, modificationTime: Date, modifiedUser: Shared.TerminologyUser, term: String, termBankId: Int, type: Shared.FullTermWithUserType, approvedTermExtension: Shared.ApprovedTermExtension? = nil, backlinkedTerms: [Shared.FullLinkedTerm]? = nil, description: String? = nil, examples: [Shared.TermExample]? = nil, linkedTerms: [Shared.FullLinkedTerm]? = nil, mistakes: [Shared.TermMistake]? = nil, pos: Shared.FullTermWithUserPos? = nil, tags: [Shared.TermTagResponse]? = nil) {
            self.caseSensitive = caseSensitive
            self.createdUser = createdUser
            self._creationTime = DateTime<Date>(wrappedValue: creationTime)
            self.highlight = highlight
            self.id = id
            self._modificationTime = DateTime<Date>(wrappedValue: modificationTime)
            self.modifiedUser = modifiedUser
            self.term = term
            self.termBankId = termBankId
            self.type = type
            self.approvedTermExtension = approvedTermExtension
            self.backlinkedTerms = backlinkedTerms
            self.description = description
            self.examples = examples
            self.linkedTerms = linkedTerms
            self.mistakes = mistakes
            self.pos = pos
            self.tags = tags
        }
    }

    /// A model object
    public struct TermTagResponse {
        public let id: Int
        public let parentTagId: Int
        public let tag: String
        public let termId: Int

        /// Creates an object with the specified parameters
        ///
        ///
        public init(id: Int, parentTagId: Int, tag: String, termId: Int) {
            self.id = id
            self.parentTagId = parentTagId
            self.tag = tag
            self.termId = termId
        }
    }

    public enum TermMistakePos: String, Codable, APIValue {
        case noun = "noun"
        case verb = "verb"
        case adverb = "adverb"
        case adjective = "adjective"
    }

    /// A model object
    public struct TermMistake {
        public let caseSensitive: Bool
        public let mistake: String
        public let termBankId: Int
        public let termId: Int
        public let id: Int?
        public let pos: Shared.TermMistakePos?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(caseSensitive: Bool, mistake: String, termBankId: Int, termId: Int, id: Int? = nil, pos: Shared.TermMistakePos? = nil) {
            self.caseSensitive = caseSensitive
            self.mistake = mistake
            self.termBankId = termBankId
            self.termId = termId
            self.id = id
            self.pos = pos
        }
    }

    public enum FullLinkedTermPos: String, Codable, APIValue {
        case noun = "noun"
        case verb = "verb"
        case adverb = "adverb"
        case adjective = "adjective"
    }

    /// A model object
    public struct FullLinkedTerm {
        public let caseSensitive: Bool
        public let linkedTermId: Int
        public let term: String
        public let termId: Int
        public let approvedTermExtension: Shared.ApprovedTermExtension?
        public let id: Int?
        public let pos: Shared.FullLinkedTermPos?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(caseSensitive: Bool, linkedTermId: Int, term: String, termId: Int, approvedTermExtension: Shared.ApprovedTermExtension? = nil, id: Int? = nil, pos: Shared.FullLinkedTermPos? = nil) {
            self.caseSensitive = caseSensitive
            self.linkedTermId = linkedTermId
            self.term = term
            self.termId = termId
            self.approvedTermExtension = approvedTermExtension
            self.id = id
            self.pos = pos
        }
    }

    /// A model object
    public struct ApprovedTermExtension {
        public let capitalize: Bool
        public let fixCase: Bool
        public let fixCommonMistakes: Bool
        public let termId: Int
        public let id: Int?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(capitalize: Bool, fixCase: Bool, fixCommonMistakes: Bool, termId: Int, id: Int? = nil) {
            self.capitalize = capitalize
            self.fixCase = fixCase
            self.fixCommonMistakes = fixCommonMistakes
            self.termId = termId
            self.id = id
        }
    }

    public enum TermExampleType: String, Codable, APIValue {
        case good = "good"
        case bad = "bad"
    }

    /// A model object
    public struct TermExample {
        public let example: String
        public let termBankId: Int
        public let termId: Int
        public let type: Shared.TermExampleType
        public let id: Int?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(example: String, termBankId: Int, termId: Int, type: Shared.TermExampleType, id: Int? = nil) {
            self.example = example
            self.termBankId = termBankId
            self.termId = termId
            self.type = type
            self.id = id
        }
    }

    public enum CreateTermsRequestFailHandling: String, Codable, APIValue {
        case accumulate = "accumulate"
        case validate = "validate"
        case skip = "skip"
        case validateOnly = "validateOnly"
    }

    /// A request model
    public struct CreateTermsRequest {
        public let failHandling: Shared.CreateTermsRequestFailHandling?
        public let models: [Shared.TermCreate]?

        /// Creates a request model with the specified parameters
        ///
        ///
        public init(failHandling: Shared.CreateTermsRequestFailHandling? = nil, models: [Shared.TermCreate]? = nil) {
            self.failHandling = failHandling
            self.models = models
        }
    }

    public enum TermCreatePos: String, Codable, APIValue {
        case noun = "noun"
        case verb = "verb"
        case adverb = "adverb"
        case adjective = "adjective"
    }

    public enum TermCreateType: String, Codable, APIValue {
        case approved = "approved"
        case banned = "banned"
        case pending = "pending"
    }

    /// A model object
    public struct TermCreate {
        public let caseSensitive: Bool
        public let term: String
        public let type: Shared.TermCreateType
        public let approvedTermExtension: Shared.ApprovedTermExtensionCreate?
        public let description: String?
        public let examples: [Shared.TermExampleCreate]?
        public let highlight: Bool?
        public let linkedTerms: [Shared.LinkedTermCreate]?
        public let mistakes: [Shared.TermMistakeCreate]?
        public let pos: Shared.TermCreatePos?
        public let reference: String?
        public let tags: [Shared.TermTagCreate]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(caseSensitive: Bool, term: String, type: Shared.TermCreateType, approvedTermExtension: Shared.ApprovedTermExtensionCreate? = nil, description: String? = nil, examples: [Shared.TermExampleCreate]? = nil, highlight: Bool? = nil, linkedTerms: [Shared.LinkedTermCreate]? = nil, mistakes: [Shared.TermMistakeCreate]? = nil, pos: Shared.TermCreatePos? = nil, reference: String? = nil, tags: [Shared.TermTagCreate]? = nil) {
            self.caseSensitive = caseSensitive
            self.term = term
            self.type = type
            self.approvedTermExtension = approvedTermExtension
            self.description = description
            self.examples = examples
            self.highlight = highlight
            self.linkedTerms = linkedTerms
            self.mistakes = mistakes
            self.pos = pos
            self.reference = reference
            self.tags = tags
        }
    }

    /// A model object
    public struct TermTagCreate {
        public let tag: String

        /// Creates an object with the specified parameters
        ///
        ///
        public init(tag: String) {
            self.tag = tag
        }
    }

    public enum TermMistakeCreatePos: String, Codable, APIValue {
        case noun = "noun"
        case verb = "verb"
        case adverb = "adverb"
        case adjective = "adjective"
    }

    /// A model object
    public struct TermMistakeCreate {
        public let caseSensitive: Bool
        public let mistake: String
        public let pos: Shared.TermMistakeCreatePos?
        public let reference: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(caseSensitive: Bool, mistake: String, pos: Shared.TermMistakeCreatePos? = nil, reference: String? = nil) {
            self.caseSensitive = caseSensitive
            self.mistake = mistake
            self.pos = pos
            self.reference = reference
        }
    }

    /// A model object
    public struct LinkedTermCreate {
        public let linkedTermId: Int?
        public let reference: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(linkedTermId: Int? = nil, reference: String? = nil) {
            self.linkedTermId = linkedTermId
            self.reference = reference
        }
    }

    public enum TermExampleCreateType: String, Codable, APIValue {
        case good = "good"
        case bad = "bad"
    }

    /// A model object
    public struct TermExampleCreate {
        public let example: String
        public let type: Shared.TermExampleCreateType

        /// Creates an object with the specified parameters
        ///
        ///
        public init(example: String, type: Shared.TermExampleCreateType) {
            self.example = example
            self.type = type
        }
    }

    /// A model object
    public struct ApprovedTermExtensionCreate {
        public let capitalize: Bool
        public let fixCase: Bool
        public let fixCommonMistakes: Bool

        /// Creates an object with the specified parameters
        ///
        ///
        public init(capitalize: Bool, fixCase: Bool, fixCommonMistakes: Bool) {
            self.capitalize = capitalize
            self.fixCase = fixCase
            self.fixCommonMistakes = fixCommonMistakes
        }
    }

    /// A model object
    public struct PaginatedResultFullTermWithUser {
        public let pagination: Shared.Pagination
        public let totalCount: Int
        public let result: [Shared.FullTermWithUser]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(pagination: Shared.Pagination, totalCount: Int, result: [Shared.FullTermWithUser]? = nil) {
            self.pagination = pagination
            self.totalCount = totalCount
            self.result = result
        }
    }

    public enum UpdateTermsRequestFailHandling: String, Codable, APIValue {
        case accumulate = "accumulate"
        case validate = "validate"
        case skip = "skip"
        case validateOnly = "validateOnly"
    }

    /// A model object
    public struct UpdateTermsRequestShared {
        public let failHandling: Shared.UpdateTermsRequestFailHandling?
        public let models: [Shared.TermUpdate]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(failHandling: Shared.UpdateTermsRequestFailHandling? = nil, models: [Shared.TermUpdate]? = nil) {
            self.failHandling = failHandling
            self.models = models
        }
    }

    public enum TermUpdatePos: String, Codable, APIValue {
        case noun = "noun"
        case verb = "verb"
        case adverb = "adverb"
        case adjective = "adjective"
    }

    public enum TermUpdateType: String, Codable, APIValue {
        case approved = "approved"
        case banned = "banned"
        case pending = "pending"
    }

    /// A model object
    public struct TermUpdate {
        public let caseSensitive: Bool
        public let id: Int
        public let term: String
        public let type: Shared.TermUpdateType
        public let approvedTermExtension: Shared.ApprovedTermExtensionCreate?
        public let description: String?
        public let examples: [Shared.TermExampleCreate]?
        public let highlight: Bool?
        public let linkedTerms: [Shared.LinkedTermCreate]?
        public let mistakes: [Shared.TermMistakeCreate]?
        public let pos: Shared.TermUpdatePos?
        public let tags: [Shared.TermTagCreate]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(caseSensitive: Bool, id: Int, term: String, type: Shared.TermUpdateType, approvedTermExtension: Shared.ApprovedTermExtensionCreate? = nil, description: String? = nil, examples: [Shared.TermExampleCreate]? = nil, highlight: Bool? = nil, linkedTerms: [Shared.LinkedTermCreate]? = nil, mistakes: [Shared.TermMistakeCreate]? = nil, pos: Shared.TermUpdatePos? = nil, tags: [Shared.TermTagCreate]? = nil) {
            self.caseSensitive = caseSensitive
            self.id = id
            self.term = term
            self.type = type
            self.approvedTermExtension = approvedTermExtension
            self.description = description
            self.examples = examples
            self.highlight = highlight
            self.linkedTerms = linkedTerms
            self.mistakes = mistakes
            self.pos = pos
            self.tags = tags
        }
    }

    /// A model object
    public struct PaginatedResultUserPublicResponse {
        public let pagination: Shared.Pagination
        public let totalCount: Int
        public let result: [Shared.UserPublicResponse]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(pagination: Shared.Pagination, totalCount: Int, result: [Shared.UserPublicResponse]? = nil) {
            self.pagination = pagination
            self.totalCount = totalCount
            self.result = result
        }
    }

    public enum UserPublicResponseAccountStatus: String, Codable, APIValue {
        case invited = "invited"
        case signedUp = "signed_up"
    }

    /// A model object
    public struct UserPublicResponse {
        public let accountStatus: Shared.UserPublicResponseAccountStatus
        @DateTime
        public private(set) var createdAt: Date
        public let firstName: String
        public let fullName: String
        public let id: Int
        public let avatar: String?
        public let email: String?
        public let invitedBy: Int?
        public let lastName: String?
        @DateTime
        public private(set) var lastSeenOnline: Date?
        public let timezone: String?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(accountStatus: Shared.UserPublicResponseAccountStatus, createdAt: Date, firstName: String, fullName: String, id: Int, avatar: String? = nil, email: String? = nil, invitedBy: Int? = nil, lastName: String? = nil, lastSeenOnline: Date? = nil, timezone: String? = nil) {
            self.accountStatus = accountStatus
            self._createdAt = DateTime<Date>(wrappedValue: createdAt)
            self.firstName = firstName
            self.fullName = fullName
            self.id = id
            self.avatar = avatar
            self.email = email
            self.invitedBy = invitedBy
            self.lastName = lastName
            self._lastSeenOnline = DateTime<Date?>(wrappedValue: lastSeenOnline)
            self.timezone = timezone
        }
    }

    public enum DocumentAccess: String, Codable, APIValue {
        case `private` = "private"
        case `public` = "public"
        case shared = "shared"
    }

    /// A model object
    public struct Document {
        public let access: Shared.DocumentAccess
        public let content: String
        @DateTime
        public private(set) var creationTime: Date
        public let id: Int
        @DateTime
        public private(set) var modificationTime: Date
        public let organizationId: Int
        public let score: Int
        public let teamId: Int
        public let title: String
        public let createdUser: Shared.SimpleUser?
        public let modifiedUser: Shared.SimpleUser?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(access: Shared.DocumentAccess, content: String, creationTime: Date, id: Int, modificationTime: Date, organizationId: Int, score: Int, teamId: Int, title: String, createdUser: Shared.SimpleUser? = nil, modifiedUser: Shared.SimpleUser? = nil) {
            self.access = access
            self.content = content
            self._creationTime = DateTime<Date>(wrappedValue: creationTime)
            self.id = id
            self._modificationTime = DateTime<Date>(wrappedValue: modificationTime)
            self.organizationId = organizationId
            self.score = score
            self.teamId = teamId
            self.title = title
            self.createdUser = createdUser
            self.modifiedUser = modifiedUser
        }
    }

    /// A model object
    public struct BriefDocuments {
        public let pagination: Shared.Pagination
        public let totalCount: Int
        public let result: [Shared.BriefDocument]?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(pagination: Shared.Pagination, totalCount: Int, result: [Shared.BriefDocument]? = nil) {
            self.pagination = pagination
            self.totalCount = totalCount
            self.result = result
        }
    }

    public enum BriefDocumentAccess: String, Codable, APIValue {
        case `private` = "private"
        case `public` = "public"
        case shared = "shared"
    }

    /// A model object
    public struct BriefDocument {
        public let access: Shared.BriefDocumentAccess
        @DateTime
        public private(set) var creationTime: Date
        public let id: Int
        @DateTime
        public private(set) var modificationTime: Date
        public let organizationId: Int
        public let score: Int
        public let teamId: Int
        public let title: String
        public let createdUser: Shared.SimpleUser?
        public let modifiedUser: Shared.SimpleUser?

        /// Creates an object with the specified parameters
        ///
        ///
        public init(access: Shared.BriefDocumentAccess, creationTime: Date, id: Int, modificationTime: Date, organizationId: Int, score: Int, teamId: Int, title: String, createdUser: Shared.SimpleUser? = nil, modifiedUser: Shared.SimpleUser? = nil) {
            self.access = access
            self._creationTime = DateTime<Date>(wrappedValue: creationTime)
            self.id = id
            self._modificationTime = DateTime<Date>(wrappedValue: modificationTime)
            self.organizationId = organizationId
            self.score = score
            self.teamId = teamId
            self.title = title
            self.createdUser = createdUser
            self.modifiedUser = modifiedUser
        }
    }

}

extension Shared.FailResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case extras
        case tpe
        case errors
    }
}

extension Shared.FailMessage: Codable {
    enum CodingKeys: String, CodingKey {
        case description
        case extras
        case key
    }
}

extension Shared.ContentDetectorResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case label
        case score
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.label = try container.decode(Shared.ContentDetectorResponseLabel.self, forKey: .label)
        self._score = try container.decode(DecimalSerialized<Double>.self, forKey: .score)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.label, forKey: .label)
        try container.encode(self._score, forKey: .score)
    }
}

extension Shared.ContentDetectorResponse {
    var scoreWrapper: DecimalSerialized<Double> {
        return _score
    }
}

extension Shared.ContentDetectorRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case input
    }
}

extension Shared.SubscriptionPublicResponseApi: Codable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case meta
        case productName
        case seats
        case status
        case subscriptionId
        case usage
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.meta = try container.decode(Shared.MetaData.self, forKey: .meta)
        self.productName = try container.decode(Shared.SubscriptionPublicResponseApiProductName.self, forKey: .productName)
        self.seats = try container.decode(Int.self, forKey: .seats)
        self.status = try container.decode(Shared.SubscriptionPublicResponseApiStatus.self, forKey: .status)
        self.subscriptionId = try container.decode(String.self, forKey: .subscriptionId)
        self.usage = try container.decode(Shared.Usage.self, forKey: .usage)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.meta, forKey: .meta)
        try container.encode(self.productName, forKey: .productName)
        try container.encode(self.seats, forKey: .seats)
        try container.encode(self.status, forKey: .status)
        try container.encode(self.subscriptionId, forKey: .subscriptionId)
        try container.encode(self.usage, forKey: .usage)
    }
}

extension Shared.SubscriptionPublicResponseApi {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
}

extension Shared.Usage: Codable {
    enum CodingKeys: String, CodingKey {
        case coWriteWords
        case team
        case user
        case words
    }
}

extension Shared.UsageItem: Codable {
    enum CodingKeys: String, CodingKey {
        case limit
        case value
    }
}

extension Shared.MetaData: Codable {
    enum CodingKeys: String, CodingKey {
        case portal
        case reporting
        case snippetsCount
        case ssoAccess
        case styleguide
        case teamCount
        case termsCount
        case tier
    }
}

extension Shared.Draft: Codable {
    enum CodingKeys: String, CodingKey {
        case body
        case createdUserId
        case creationTime
        case deleted
        case documentId
        case inputs
        case organizationId
        case teamId
        case templateId
        case id
        case title
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.body = try container.decode(String.self, forKey: .body)
        self.createdUserId = try container.decode(Int.self, forKey: .createdUserId)
        self._creationTime = try container.decode(DateTime<Date>.self, forKey: .creationTime)
        self.deleted = try container.decode(Bool.self, forKey: .deleted)
        self.documentId = try container.decode(String.self, forKey: .documentId)
        self.inputs = try container.decode(AnyValue.self, forKey: .inputs)
        self.organizationId = try container.decode(Int.self, forKey: .organizationId)
        self.teamId = try container.decode(Int.self, forKey: .teamId)
        self.templateId = try container.decode(String.self, forKey: .templateId)
        self.id = try container.decodeIfPresent(Int.self, forKey: .id)
        self.title = try container.decodeIfPresent(String.self, forKey: .title)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.body, forKey: .body)
        try container.encode(self.createdUserId, forKey: .createdUserId)
        try container.encode(self._creationTime, forKey: .creationTime)
        try container.encode(self.deleted, forKey: .deleted)
        try container.encode(self.documentId, forKey: .documentId)
        try container.encode(self.inputs, forKey: .inputs)
        try container.encode(self.organizationId, forKey: .organizationId)
        try container.encode(self.teamId, forKey: .teamId)
        try container.encode(self.templateId, forKey: .templateId)
        try container.encodeIfPresent(self.id, forKey: .id)
        try container.encodeIfPresent(self.title, forKey: .title)
    }
}

extension Shared.Draft {
    var creationTimeWrapper: DateTime<Date> {
        return _creationTime
    }
}

extension Shared.GenerateTemplateRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case templateId
        case inputs
    }
}

extension Shared.MagicRequestInput: Codable {
    enum CodingKeys: String, CodingKey {
        case name
        case value
    }
}

extension Shared.TemplateDetailsResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case categoryId
        case creationTime
        case id
        case modificationTime
        case name
        case description
        case guideUrl
        case inputs
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.categoryId = try container.decode(Int.self, forKey: .categoryId)
        self._creationTime = try container.decode(DateTime<Date>.self, forKey: .creationTime)
        self.id = try container.decode(String.self, forKey: .id)
        self._modificationTime = try container.decode(DateTime<Date>.self, forKey: .modificationTime)
        self.name = try container.decode(String.self, forKey: .name)
        self.description = try container.decodeIfPresent(String.self, forKey: .description)
        self.guideUrl = try container.decodeIfPresent(String.self, forKey: .guideUrl)
        self.inputs = try container.decodeIfPresent([Shared.Input].self, forKey: .inputs)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.categoryId, forKey: .categoryId)
        try container.encode(self._creationTime, forKey: .creationTime)
        try container.encode(self.id, forKey: .id)
        try container.encode(self._modificationTime, forKey: .modificationTime)
        try container.encode(self.name, forKey: .name)
        try container.encodeIfPresent(self.description, forKey: .description)
        try container.encodeIfPresent(self.guideUrl, forKey: .guideUrl)
        try container.encodeIfPresent(self.inputs, forKey: .inputs)
    }
}

extension Shared.TemplateDetailsResponse {
    var creationTimeWrapper: DateTime<Date> {
        return _creationTime
    }
    var modificationTimeWrapper: DateTime<Date> {
        return _modificationTime
    }
}

extension Shared.Input: Codable {
    enum CodingKeys: String, CodingKey {
        case `dynamic` = "dynamic"
        case name
        case `required` = "required"
        case type
        case help
        case maxFields
        case minFields
        case options
        case subtitle
        case unitCopy
    }
}

extension Shared.CompletionResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case choices
    }
}

extension Shared.CompletionGenerationChoice: Codable {
    enum CodingKeys: String, CodingKey {
        case text
        case logprobs
    }
}

extension Shared.CompletionGenerationChoiceLogprobs: Codable {
    enum CodingKeys: String, CodingKey {
        case textOffset
        case tokenLogprobs
        case tokens
        case topLogprobs
    }
}

extension Shared.CompletionRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case prompt
        case bestOf
        case frequencyPenalty
        case logprobs
        case maxTokens
        case minTokens
        case n
        case presencePenalty
        case stop
        case temperature
        case topP
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.prompt = try container.decode(String.self, forKey: .prompt)
        self.bestOf = try container.decodeIfPresent(Int.self, forKey: .bestOf)
        self._frequencyPenalty = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .frequencyPenalty) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.logprobs = try container.decodeIfPresent(Int.self, forKey: .logprobs)
        self.maxTokens = try container.decodeIfPresent(Int.self, forKey: .maxTokens)
        self.minTokens = try container.decodeIfPresent(Int.self, forKey: .minTokens)
        self.n = try container.decodeIfPresent(Int.self, forKey: .n)
        self._presencePenalty = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .presencePenalty) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.stop = try container.decodeIfPresent([String].self, forKey: .stop)
        self._temperature = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .temperature) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self._topP = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .topP) ?? DecimalSerialized<Double?>(wrappedValue: nil)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.prompt, forKey: .prompt)
        try container.encodeIfPresent(self.bestOf, forKey: .bestOf)
        if self.frequencyPenalty != nil {
            try container.encode(self._frequencyPenalty, forKey: .frequencyPenalty)
        }
        try container.encodeIfPresent(self.logprobs, forKey: .logprobs)
        try container.encodeIfPresent(self.maxTokens, forKey: .maxTokens)
        try container.encodeIfPresent(self.minTokens, forKey: .minTokens)
        try container.encodeIfPresent(self.n, forKey: .n)
        if self.presencePenalty != nil {
            try container.encode(self._presencePenalty, forKey: .presencePenalty)
        }
        try container.encodeIfPresent(self.stop, forKey: .stop)
        if self.temperature != nil {
            try container.encode(self._temperature, forKey: .temperature)
        }
        if self.topP != nil {
            try container.encode(self._topP, forKey: .topP)
        }
    }
}

extension Shared.CompletionRequest {
    var frequencyPenaltyWrapper: DecimalSerialized<Double?> {
        return _frequencyPenalty
    }
    var presencePenaltyWrapper: DecimalSerialized<Double?> {
        return _presencePenalty
    }
    var temperatureWrapper: DecimalSerialized<Double?> {
        return _temperature
    }
    var topPWrapper: DecimalSerialized<Double?> {
        return _topP
    }
}

extension Shared.ProcessedContent: Codable {
    enum CodingKeys: String, CodingKey {
        case issues
    }
}

extension Shared.ContentIssue: Codable {
    enum CodingKeys: String, CodingKey {
        case from
        case service
        case until
        case description
        case meta
        case suggestions
    }
}

extension Shared.ContentRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case content
        case settings
    }
}

extension Shared.ContentSettings: Codable {
    enum CodingKeys: String, CodingKey {
        case ageAndFamilyStatus
        case confidence
        case contentSafeguards
        case disability
        case genderIdentitySensitivity
        case genderInclusiveNouns
        case genderInclusivePronouns
        case grammar
        case healthyCommunication
        case passiveVoice
        case raceEthnicityNationalitySensitivity
        case sexualOrientationSensitivity
        case spelling
        case substanceUseSensitivity
        case unclearReference
        case wordiness
    }
}

extension Shared.CorrectionResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case correct
    }
}

extension Shared.ModelFile: Codable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case format
        case id
        case name
        case numberOfSamples
        case size
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.format = try container.decode(String.self, forKey: .format)
        self.id = try container.decode(String.self, forKey: .id)
        self.name = try container.decode(String.self, forKey: .name)
        self.numberOfSamples = try container.decode(Int.self, forKey: .numberOfSamples)
        self.size = try container.decode(Int.self, forKey: .size)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.format, forKey: .format)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.numberOfSamples, forKey: .numberOfSamples)
        try container.encode(self.size, forKey: .size)
    }
}

extension Shared.ModelFile {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
}

extension Shared.ModelFilesResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case files
    }
}

extension Shared.ModelCustomization: Codable {
    enum CodingKeys: String, CodingKey {
        case baseModelId
        case createdAt
        case id
        case name
        case status
        case trainingDatasetFileId
        case updatedAt
        case additionalHyperParameters
        case batchSize
        case description
        case epochs
        case learningRate
        case promptTemplate
        case validationDatasetFileId
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.baseModelId = try container.decode(String.self, forKey: .baseModelId)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.id = try container.decode(String.self, forKey: .id)
        self.name = try container.decode(String.self, forKey: .name)
        self.status = try container.decode(String.self, forKey: .status)
        self.trainingDatasetFileId = try container.decode(String.self, forKey: .trainingDatasetFileId)
        self._updatedAt = try container.decode(DateTime<Date>.self, forKey: .updatedAt)
        self.additionalHyperParameters = try container.decodeIfPresent(Shared.HyperParameters.self, forKey: .additionalHyperParameters)
        self.batchSize = try container.decodeIfPresent(Int.self, forKey: .batchSize)
        self.description = try container.decodeIfPresent(String.self, forKey: .description)
        self.epochs = try container.decodeIfPresent(Int.self, forKey: .epochs)
        self._learningRate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .learningRate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.promptTemplate = try container.decodeIfPresent(String.self, forKey: .promptTemplate)
        self.validationDatasetFileId = try container.decodeIfPresent(String.self, forKey: .validationDatasetFileId)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.baseModelId, forKey: .baseModelId)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.status, forKey: .status)
        try container.encode(self.trainingDatasetFileId, forKey: .trainingDatasetFileId)
        try container.encode(self._updatedAt, forKey: .updatedAt)
        try container.encodeIfPresent(self.additionalHyperParameters, forKey: .additionalHyperParameters)
        try container.encodeIfPresent(self.batchSize, forKey: .batchSize)
        try container.encodeIfPresent(self.description, forKey: .description)
        try container.encodeIfPresent(self.epochs, forKey: .epochs)
        if self.learningRate != nil {
            try container.encode(self._learningRate, forKey: .learningRate)
        }
        try container.encodeIfPresent(self.promptTemplate, forKey: .promptTemplate)
        try container.encodeIfPresent(self.validationDatasetFileId, forKey: .validationDatasetFileId)
    }
}

extension Shared.ModelCustomization {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var learningRateWrapper: DecimalSerialized<Double?> {
        return _learningRate
    }
    var updatedAtWrapper: DateTime<Date> {
        return _updatedAt
    }
}

extension Shared.HyperParameters: Codable {
    enum CodingKeys: String, CodingKey {
        case numVirtualTokens
    }
}

extension Shared.CreateCustomizationRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case name
        case trainingDatasetFileId
        case additionalHyperParameters
        case batchSize
        case description
        case epochs
        case learningRate
        case promptTemplate
        case validationDatasetFileId
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.name = try container.decode(String.self, forKey: .name)
        self.trainingDatasetFileId = try container.decode(String.self, forKey: .trainingDatasetFileId)
        self.additionalHyperParameters = try container.decodeIfPresent(Shared.HyperParameters.self, forKey: .additionalHyperParameters)
        self.batchSize = try container.decodeIfPresent(Int.self, forKey: .batchSize)
        self.description = try container.decodeIfPresent(String.self, forKey: .description)
        self.epochs = try container.decodeIfPresent(Int.self, forKey: .epochs)
        self._learningRate = try container.decodeIfPresent(DecimalSerialized<Double?>.self, forKey: .learningRate) ?? DecimalSerialized<Double?>(wrappedValue: nil)
        self.promptTemplate = try container.decodeIfPresent(String.self, forKey: .promptTemplate)
        self.validationDatasetFileId = try container.decodeIfPresent(String.self, forKey: .validationDatasetFileId)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.name, forKey: .name)
        try container.encode(self.trainingDatasetFileId, forKey: .trainingDatasetFileId)
        try container.encodeIfPresent(self.additionalHyperParameters, forKey: .additionalHyperParameters)
        try container.encodeIfPresent(self.batchSize, forKey: .batchSize)
        try container.encodeIfPresent(self.description, forKey: .description)
        try container.encodeIfPresent(self.epochs, forKey: .epochs)
        if self.learningRate != nil {
            try container.encode(self._learningRate, forKey: .learningRate)
        }
        try container.encodeIfPresent(self.promptTemplate, forKey: .promptTemplate)
        try container.encodeIfPresent(self.validationDatasetFileId, forKey: .validationDatasetFileId)
    }
}

extension Shared.CreateCustomizationRequest {
    var learningRateWrapper: DecimalSerialized<Double?> {
        return _learningRate
    }
}

extension Shared.CustomizationsResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case customizations
    }
}

extension Shared.GenerationModelsResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case data
    }
}

extension Shared.GenerationModelInfoResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case id
        case name
        case type
    }
}

extension Shared.DeleteResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case deleted
    }
}

extension Shared.PaginatedResultSnippetWithUser: Codable {
    enum CodingKeys: String, CodingKey {
        case pagination
        case totalCount
        case result
    }
}

extension Shared.SnippetWithUser: Codable {
    enum CodingKeys: String, CodingKey {
        case createdUser
        case creationTime
        case id
        case modificationTime
        case modifiedUser
        case snippet
        case description
        case shortcut
        case tags
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.createdUser = try container.decode(Shared.TerminologyUser.self, forKey: .createdUser)
        self._creationTime = try container.decode(DateTime<Date>.self, forKey: .creationTime)
        self.id = try container.decode(String.self, forKey: .id)
        self._modificationTime = try container.decode(DateTime<Date>.self, forKey: .modificationTime)
        self.modifiedUser = try container.decode(Shared.TerminologyUser.self, forKey: .modifiedUser)
        self.snippet = try container.decode(String.self, forKey: .snippet)
        self.description = try container.decodeIfPresent(String.self, forKey: .description)
        self.shortcut = try container.decodeIfPresent(String.self, forKey: .shortcut)
        self.tags = try container.decodeIfPresent([Shared.SnippetTagV2].self, forKey: .tags)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.createdUser, forKey: .createdUser)
        try container.encode(self._creationTime, forKey: .creationTime)
        try container.encode(self.id, forKey: .id)
        try container.encode(self._modificationTime, forKey: .modificationTime)
        try container.encode(self.modifiedUser, forKey: .modifiedUser)
        try container.encode(self.snippet, forKey: .snippet)
        try container.encodeIfPresent(self.description, forKey: .description)
        try container.encodeIfPresent(self.shortcut, forKey: .shortcut)
        try container.encodeIfPresent(self.tags, forKey: .tags)
    }
}

extension Shared.SnippetWithUser {
    var creationTimeWrapper: DateTime<Date> {
        return _creationTime
    }
    var modificationTimeWrapper: DateTime<Date> {
        return _modificationTime
    }
}

extension Shared.SnippetTagV2: Codable {
    enum CodingKeys: String, CodingKey {
        case tag
    }
}

extension Shared.TerminologyUser: Codable {
    enum CodingKeys: String, CodingKey {
        case id
        case email
        case fullName
    }
}

extension Shared.Pagination: Codable {
    enum CodingKeys: String, CodingKey {
        case limit
        case offset
    }
}

extension Shared.SnippetUpdate: Codable {
    enum CodingKeys: String, CodingKey {
        case id
        case snippet
        case description
        case shortcut
        case tags
    }
}

extension Shared.PageWithSectionResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case id
        case order
        case status
        case title
        case updatedAt
        case url
        case content
        case section
        case updatedBy
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.id = try container.decode(Int.self, forKey: .id)
        self.order = try container.decode(Int.self, forKey: .order)
        self.status = try container.decode(Shared.PageWithSectionResponseStatus.self, forKey: .status)
        self.title = try container.decode(String.self, forKey: .title)
        self._updatedAt = try container.decode(DateTime<Date>.self, forKey: .updatedAt)
        self.url = try container.decode(String.self, forKey: .url)
        self.content = try container.decodeIfPresent(String.self, forKey: .content)
        self.section = try container.decodeIfPresent(Shared.SectionInfo.self, forKey: .section)
        self.updatedBy = try container.decodeIfPresent(Shared.SimpleUser.self, forKey: .updatedBy)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.order, forKey: .order)
        try container.encode(self.status, forKey: .status)
        try container.encode(self.title, forKey: .title)
        try container.encode(self._updatedAt, forKey: .updatedAt)
        try container.encode(self.url, forKey: .url)
        try container.encodeIfPresent(self.content, forKey: .content)
        try container.encodeIfPresent(self.section, forKey: .section)
        try container.encodeIfPresent(self.updatedBy, forKey: .updatedBy)
    }
}

extension Shared.PageWithSectionResponse {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var updatedAtWrapper: DateTime<Date> {
        return _updatedAt
    }
}

extension Shared.SimpleUser: Codable {
    enum CodingKeys: String, CodingKey {
        case firstName
        case id
        case email
        case lastName
    }
}

extension Shared.SectionInfo: Codable {
    enum CodingKeys: String, CodingKey {
        case id
        case title
        case url
    }
}

extension Shared.PaginatedResultPagePublicApiResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case pagination
        case totalCount
        case result
    }
}

extension Shared.PagePublicApiResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case createdAt
        case id
        case order
        case status
        case title
        case updatedAt
        case url
        case section
        case updatedBy
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.id = try container.decode(Int.self, forKey: .id)
        self.order = try container.decode(Int.self, forKey: .order)
        self.status = try container.decode(Shared.PagePublicApiResponseStatus.self, forKey: .status)
        self.title = try container.decode(String.self, forKey: .title)
        self._updatedAt = try container.decode(DateTime<Date>.self, forKey: .updatedAt)
        self.url = try container.decode(String.self, forKey: .url)
        self.section = try container.decodeIfPresent(Shared.SectionInfo.self, forKey: .section)
        self.updatedBy = try container.decodeIfPresent(Shared.SimpleUser.self, forKey: .updatedBy)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.id, forKey: .id)
        try container.encode(self.order, forKey: .order)
        try container.encode(self.status, forKey: .status)
        try container.encode(self.title, forKey: .title)
        try container.encode(self._updatedAt, forKey: .updatedAt)
        try container.encode(self.url, forKey: .url)
        try container.encodeIfPresent(self.section, forKey: .section)
        try container.encodeIfPresent(self.updatedBy, forKey: .updatedBy)
    }
}

extension Shared.PagePublicApiResponse {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var updatedAtWrapper: DateTime<Date> {
        return _updatedAt
    }
}

extension Shared.CreateTermsResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case fails
        case models
    }
}

extension Shared.FullTermWithUser: Codable {
    enum CodingKeys: String, CodingKey {
        case caseSensitive
        case createdUser
        case creationTime
        case highlight
        case id
        case modificationTime
        case modifiedUser
        case term
        case termBankId
        case type
        case approvedTermExtension
        case backlinkedTerms
        case description
        case examples
        case linkedTerms
        case mistakes
        case pos
        case tags
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.caseSensitive = try container.decode(Bool.self, forKey: .caseSensitive)
        self.createdUser = try container.decode(Shared.TerminologyUser.self, forKey: .createdUser)
        self._creationTime = try container.decode(DateTime<Date>.self, forKey: .creationTime)
        self.highlight = try container.decode(Bool.self, forKey: .highlight)
        self.id = try container.decode(Int.self, forKey: .id)
        self._modificationTime = try container.decode(DateTime<Date>.self, forKey: .modificationTime)
        self.modifiedUser = try container.decode(Shared.TerminologyUser.self, forKey: .modifiedUser)
        self.term = try container.decode(String.self, forKey: .term)
        self.termBankId = try container.decode(Int.self, forKey: .termBankId)
        self.type = try container.decode(Shared.FullTermWithUserType.self, forKey: .type)
        self.approvedTermExtension = try container.decodeIfPresent(Shared.ApprovedTermExtension.self, forKey: .approvedTermExtension)
        self.backlinkedTerms = try container.decodeIfPresent([Shared.FullLinkedTerm].self, forKey: .backlinkedTerms)
        self.description = try container.decodeIfPresent(String.self, forKey: .description)
        self.examples = try container.decodeIfPresent([Shared.TermExample].self, forKey: .examples)
        self.linkedTerms = try container.decodeIfPresent([Shared.FullLinkedTerm].self, forKey: .linkedTerms)
        self.mistakes = try container.decodeIfPresent([Shared.TermMistake].self, forKey: .mistakes)
        self.pos = try container.decodeIfPresent(Shared.FullTermWithUserPos.self, forKey: .pos)
        self.tags = try container.decodeIfPresent([Shared.TermTagResponse].self, forKey: .tags)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.caseSensitive, forKey: .caseSensitive)
        try container.encode(self.createdUser, forKey: .createdUser)
        try container.encode(self._creationTime, forKey: .creationTime)
        try container.encode(self.highlight, forKey: .highlight)
        try container.encode(self.id, forKey: .id)
        try container.encode(self._modificationTime, forKey: .modificationTime)
        try container.encode(self.modifiedUser, forKey: .modifiedUser)
        try container.encode(self.term, forKey: .term)
        try container.encode(self.termBankId, forKey: .termBankId)
        try container.encode(self.type, forKey: .type)
        try container.encodeIfPresent(self.approvedTermExtension, forKey: .approvedTermExtension)
        try container.encodeIfPresent(self.backlinkedTerms, forKey: .backlinkedTerms)
        try container.encodeIfPresent(self.description, forKey: .description)
        try container.encodeIfPresent(self.examples, forKey: .examples)
        try container.encodeIfPresent(self.linkedTerms, forKey: .linkedTerms)
        try container.encodeIfPresent(self.mistakes, forKey: .mistakes)
        try container.encodeIfPresent(self.pos, forKey: .pos)
        try container.encodeIfPresent(self.tags, forKey: .tags)
    }
}

extension Shared.FullTermWithUser {
    var creationTimeWrapper: DateTime<Date> {
        return _creationTime
    }
    var modificationTimeWrapper: DateTime<Date> {
        return _modificationTime
    }
}

extension Shared.TermTagResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case id
        case parentTagId
        case tag
        case termId
    }
}

extension Shared.TermMistake: Codable {
    enum CodingKeys: String, CodingKey {
        case caseSensitive
        case mistake
        case termBankId
        case termId
        case id
        case pos
    }
}

extension Shared.FullLinkedTerm: Codable {
    enum CodingKeys: String, CodingKey {
        case caseSensitive
        case linkedTermId
        case term
        case termId
        case approvedTermExtension
        case id
        case pos
    }
}

extension Shared.ApprovedTermExtension: Codable {
    enum CodingKeys: String, CodingKey {
        case capitalize
        case fixCase
        case fixCommonMistakes
        case termId
        case id
    }
}

extension Shared.TermExample: Codable {
    enum CodingKeys: String, CodingKey {
        case example
        case termBankId
        case termId
        case type
        case id
    }
}

extension Shared.CreateTermsRequest: Codable {
    enum CodingKeys: String, CodingKey {
        case failHandling
        case models
    }
}

extension Shared.TermCreate: Codable {
    enum CodingKeys: String, CodingKey {
        case caseSensitive
        case term
        case type
        case approvedTermExtension
        case description
        case examples
        case highlight
        case linkedTerms
        case mistakes
        case pos
        case reference
        case tags
    }
}

extension Shared.TermTagCreate: Codable {
    enum CodingKeys: String, CodingKey {
        case tag
    }
}

extension Shared.TermMistakeCreate: Codable {
    enum CodingKeys: String, CodingKey {
        case caseSensitive
        case mistake
        case pos
        case reference
    }
}

extension Shared.LinkedTermCreate: Codable {
    enum CodingKeys: String, CodingKey {
        case linkedTermId
        case reference
    }
}

extension Shared.TermExampleCreate: Codable {
    enum CodingKeys: String, CodingKey {
        case example
        case type
    }
}

extension Shared.ApprovedTermExtensionCreate: Codable {
    enum CodingKeys: String, CodingKey {
        case capitalize
        case fixCase
        case fixCommonMistakes
    }
}

extension Shared.PaginatedResultFullTermWithUser: Codable {
    enum CodingKeys: String, CodingKey {
        case pagination
        case totalCount
        case result
    }
}

extension Shared.UpdateTermsRequestShared: Codable {
    enum CodingKeys: String, CodingKey {
        case failHandling
        case models
    }
}

extension Shared.TermUpdate: Codable {
    enum CodingKeys: String, CodingKey {
        case caseSensitive
        case id
        case term
        case type
        case approvedTermExtension
        case description
        case examples
        case highlight
        case linkedTerms
        case mistakes
        case pos
        case tags
    }
}

extension Shared.PaginatedResultUserPublicResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case pagination
        case totalCount
        case result
    }
}

extension Shared.UserPublicResponse: Codable {
    enum CodingKeys: String, CodingKey {
        case accountStatus
        case createdAt
        case firstName
        case fullName
        case id
        case avatar
        case email
        case invitedBy
        case lastName
        case lastSeenOnline
        case timezone
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.accountStatus = try container.decode(Shared.UserPublicResponseAccountStatus.self, forKey: .accountStatus)
        self._createdAt = try container.decode(DateTime<Date>.self, forKey: .createdAt)
        self.firstName = try container.decode(String.self, forKey: .firstName)
        self.fullName = try container.decode(String.self, forKey: .fullName)
        self.id = try container.decode(Int.self, forKey: .id)
        self.avatar = try container.decodeIfPresent(String.self, forKey: .avatar)
        self.email = try container.decodeIfPresent(String.self, forKey: .email)
        self.invitedBy = try container.decodeIfPresent(Int.self, forKey: .invitedBy)
        self.lastName = try container.decodeIfPresent(String.self, forKey: .lastName)
        self._lastSeenOnline = try container.decodeIfPresent(DateTime<Date?>.self, forKey: .lastSeenOnline) ?? DateTime<Date?>(wrappedValue: nil)
        self.timezone = try container.decodeIfPresent(String.self, forKey: .timezone)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.accountStatus, forKey: .accountStatus)
        try container.encode(self._createdAt, forKey: .createdAt)
        try container.encode(self.firstName, forKey: .firstName)
        try container.encode(self.fullName, forKey: .fullName)
        try container.encode(self.id, forKey: .id)
        try container.encodeIfPresent(self.avatar, forKey: .avatar)
        try container.encodeIfPresent(self.email, forKey: .email)
        try container.encodeIfPresent(self.invitedBy, forKey: .invitedBy)
        try container.encodeIfPresent(self.lastName, forKey: .lastName)
        if self.lastSeenOnline != nil {
            try container.encode(self._lastSeenOnline, forKey: .lastSeenOnline)
        }
        try container.encodeIfPresent(self.timezone, forKey: .timezone)
    }
}

extension Shared.UserPublicResponse {
    var createdAtWrapper: DateTime<Date> {
        return _createdAt
    }
    var lastSeenOnlineWrapper: DateTime<Date?> {
        return _lastSeenOnline
    }
}

extension Shared.Document: Codable {
    enum CodingKeys: String, CodingKey {
        case access
        case content
        case creationTime
        case id
        case modificationTime
        case organizationId
        case score
        case teamId
        case title
        case createdUser
        case modifiedUser
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.access = try container.decode(Shared.DocumentAccess.self, forKey: .access)
        self.content = try container.decode(String.self, forKey: .content)
        self._creationTime = try container.decode(DateTime<Date>.self, forKey: .creationTime)
        self.id = try container.decode(Int.self, forKey: .id)
        self._modificationTime = try container.decode(DateTime<Date>.self, forKey: .modificationTime)
        self.organizationId = try container.decode(Int.self, forKey: .organizationId)
        self.score = try container.decode(Int.self, forKey: .score)
        self.teamId = try container.decode(Int.self, forKey: .teamId)
        self.title = try container.decode(String.self, forKey: .title)
        self.createdUser = try container.decodeIfPresent(Shared.SimpleUser.self, forKey: .createdUser)
        self.modifiedUser = try container.decodeIfPresent(Shared.SimpleUser.self, forKey: .modifiedUser)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.access, forKey: .access)
        try container.encode(self.content, forKey: .content)
        try container.encode(self._creationTime, forKey: .creationTime)
        try container.encode(self.id, forKey: .id)
        try container.encode(self._modificationTime, forKey: .modificationTime)
        try container.encode(self.organizationId, forKey: .organizationId)
        try container.encode(self.score, forKey: .score)
        try container.encode(self.teamId, forKey: .teamId)
        try container.encode(self.title, forKey: .title)
        try container.encodeIfPresent(self.createdUser, forKey: .createdUser)
        try container.encodeIfPresent(self.modifiedUser, forKey: .modifiedUser)
    }
}

extension Shared.Document {
    var creationTimeWrapper: DateTime<Date> {
        return _creationTime
    }
    var modificationTimeWrapper: DateTime<Date> {
        return _modificationTime
    }
}

extension Shared.BriefDocuments: Codable {
    enum CodingKeys: String, CodingKey {
        case pagination
        case totalCount
        case result
    }
}

extension Shared.BriefDocument: Codable {
    enum CodingKeys: String, CodingKey {
        case access
        case creationTime
        case id
        case modificationTime
        case organizationId
        case score
        case teamId
        case title
        case createdUser
        case modifiedUser
    }

    public init(from decoder: Decoder) throws {
        let container = try decoder.container(keyedBy: CodingKeys.self)
        self.access = try container.decode(Shared.BriefDocumentAccess.self, forKey: .access)
        self._creationTime = try container.decode(DateTime<Date>.self, forKey: .creationTime)
        self.id = try container.decode(Int.self, forKey: .id)
        self._modificationTime = try container.decode(DateTime<Date>.self, forKey: .modificationTime)
        self.organizationId = try container.decode(Int.self, forKey: .organizationId)
        self.score = try container.decode(Int.self, forKey: .score)
        self.teamId = try container.decode(Int.self, forKey: .teamId)
        self.title = try container.decode(String.self, forKey: .title)
        self.createdUser = try container.decodeIfPresent(Shared.SimpleUser.self, forKey: .createdUser)
        self.modifiedUser = try container.decodeIfPresent(Shared.SimpleUser.self, forKey: .modifiedUser)
    }

    public func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        try container.encode(self.access, forKey: .access)
        try container.encode(self._creationTime, forKey: .creationTime)
        try container.encode(self.id, forKey: .id)
        try container.encode(self._modificationTime, forKey: .modificationTime)
        try container.encode(self.organizationId, forKey: .organizationId)
        try container.encode(self.score, forKey: .score)
        try container.encode(self.teamId, forKey: .teamId)
        try container.encode(self.title, forKey: .title)
        try container.encodeIfPresent(self.createdUser, forKey: .createdUser)
        try container.encodeIfPresent(self.modifiedUser, forKey: .modifiedUser)
    }
}

extension Shared.BriefDocument {
    var creationTimeWrapper: DateTime<Date> {
        return _creationTime
    }
    var modificationTimeWrapper: DateTime<Date> {
        return _modificationTime
    }
}